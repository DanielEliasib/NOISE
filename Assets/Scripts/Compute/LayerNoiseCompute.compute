// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel NoiseGenerator

#include "kj/SimplexNoise3D.hlsl"
#include "kj/BCCNoise8.hlsl"

StructuredBuffer<float3> _Colors;

RWTexture2DArray<float4> _TexArray;

int levels;
int numberOfColors;

float _Frecuency1;
float _Frecuency2;

float2 _Offset1, _Offset2;

float _Time, _K, _W;

float A(float t)
{
    //return 1.0f / exp(t);
    return 0.5f;
}

float WaveFunction(float r, float k, float w, float t)
{
    return A(t) * cos(k * r - w * t);
}

[numthreads(8, 8, 1)]
void NoiseGenerator(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float noise =
        dot(
            snoise_grad((id + float3(0, _Offset1)) / _Frecuency1).xyz,
            snoise_grad((id + float3(_Offset2, 0)) / _Frecuency2).xyz
            );
    
    //Remap noise. I think dot(noise, noise) give us at most 1*1 + 1*1 + 1*1 = 3, and at least -1*1 -1*1 -1*1 = -3
    //So I remap [-3,3] to [0, 1]
    //noise = 0;

    noise = (noise / 15.0f + 0.5f) * 0.7f;
    //noise = 0;
    uint3 wavePoint = id - int3(960/2, 960/2, 0);
    float vel = _W / _K;
    float lamb = 2 * 3.14159 / _K;
    float wNoise = 0;
    
    float wRad = sqrt(wavePoint.x * wavePoint.x + wavePoint.y * wavePoint.y);
    
    if (abs(vel * _Time - wRad) <= lamb*0.5f)
    {
        noise += WaveFunction(sqrt(wavePoint.x * wavePoint.x + wavePoint.y * wavePoint.y), _K, _W, _Time);
    }
    
    noise = noise + wNoise;
    
    float step = (1.0f) / (levels);
    
    for (int i = 0; i < levels; i++)
    {
        if ((i + 1) * step <= noise)
        {
            int currentColor = (int) (i * step * (numberOfColors - 1));
            
            float3 color = lerp(_Colors[currentColor], _Colors[currentColor + 1], i * step * numberOfColors - currentColor);
            
            _TexArray[uint3(id.xy, i)] = float4(color, 1.0f);
        }
        else
        {
            _TexArray[uint3(id.xy, i)] = float4(0.0f, 0.0f, 0.0f, 0.0f);
        }
        
        
    }
}



